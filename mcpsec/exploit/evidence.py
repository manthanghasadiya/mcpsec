"""
Evidence capture and PoC generation for the exploitation session.
"""

import json
from datetime import datetime
from dataclasses import dataclass, field
from typing import List

from .state_tracker import ExploitState

@dataclass
class EvidenceBundle:
    """A bundle representing all exploited findings during a session."""
    session_id: str
    target: str
    timestamp: datetime = field(default_factory=datetime.now)
    exploited_states: List[ExploitState] = field(default_factory=list)

    def to_dict(self) -> dict:
        """Serialize evidence bundle to dict (for JSON export)."""
        return {
            "session_id": self.session_id,
            "target": self.target,
            "timestamp": self.timestamp.isoformat(),
            "findings": [
                {
                    "finding_title": state.finding.title if state.finding else "Manual Exploration",
                    "confirmed": state.confirmed,
                    "target": state.target,
                    "attempts": [
                        {
                            "timestamp": a.timestamp.isoformat(),
                            "tool": a.tool,
                            "payload": a.payload,
                            "response": str(a.response),
                            "latency_ms": a.latency_ms,
                            "success": a.success,
                            "notes": a.notes
                        } for a in state.attempts
                    ]
                }
                for state in self.exploited_states
            ]
        }

def generate_poc_script(state: ExploitState, server_cmd: str) -> str:
    """
    Generates a generic standalone Python PoC script based on an ExploitState.
    Finds the successful attempt and generates a script testing it.
    """
    successful_attempts = [a for a in state.attempts if a.success]
    if not successful_attempts:
        return "# No successful exploitation attempts found to generate PoC."
        
    last_success = successful_attempts[-1]
    tool_name = last_success.tool
    payload = last_success.payload
    
    poc_template = f'''#!/usr/bin/env python3
"""
PoC for MCP Server vulnerability
Generated by mcpsec Exploit Session
Date: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}
"""

import subprocess, json, sys, time

SERVER_CMD = {repr(server_cmd)}

def send_jsonrpc(proc, msg):
    try:
        proc.stdin.write(json.dumps(msg) + "\\n")
        proc.stdin.flush()
        line = proc.stdout.readline()
        if not line:
            return None
        return json.loads(line)
    except Exception as e:
        print(f"[-] Error communicating: {{e}}")
        return None

def main():
    print("[*] Starting MCP Server...")
    proc = subprocess.Popen(SERVER_CMD.split(), stdin=subprocess.PIPE,
                           stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
    
    # Initialize Handshake
    print("[*] Sending initialization...")
    send_jsonrpc(proc, {{
        "jsonrpc": "2.0", "id": 1, "method": "initialize",
        "params": {{"protocolVersion": "2024-11-05", "capabilities": {{}},
                   "clientInfo": {{"name": "mcpsec-poc", "version": "1.0"}}}}
    }})
    proc.stdin.write(json.dumps({{"jsonrpc":"2.0","method":"notifications/initialized"}}) + "\\n")
    proc.stdin.flush()
    time.sleep(0.5)
    
    # Exploit Request
    print("[*] Sending exploit payload to {tool_name}...")
    result = send_jsonrpc(proc, {{
        "jsonrpc": "2.0", "id": 2, "method": "tools/call",
        "params": {{"name": "{tool_name}", "arguments": {json.dumps(payload)}}}
    }})
    
    print("[*] Response:")
    print(json.dumps(result, indent=2) if result else "None")
    
    proc.terminate()

if __name__ == "__main__":
    main()
'''
    return poc_template
