"""
The main controller for the interactive session.
"""
from typing import Optional, List, Any
import json
import asyncio
from datetime import datetime
import shlex
import traceback
from time import perf_counter

from rich.syntax import Syntax

from mcpsec.models import ServerProfile, Finding, TransportType
from .connection import establish_connection
from .state_tracker import ExploitState, AttemptRecord
from .evidence import EvidenceBundle, generate_poc_script
from .payload_engine import PayloadEngine
from .playbooks import PayloadEntry
from .mcp_repl import MCPRepl
from .formatters import print_repl_banner, print_help, print_tool_list, print_json_response, repl_console

class ExploitSession:
    def __init__(self, target: str, transport: TransportType, findings: List[Finding] = None, use_ai: bool = False, headers: Optional[dict] = None, client=None, profile=None):
        self.target = target
        self.transport = transport
        self.findings = findings or []
        self.use_ai = use_ai
        self.headers = headers
        
        self.client = client
        self.profile: Optional[ServerProfile] = profile
        self._owns_client = (client is None)
        
        self.states: List[ExploitState] = []
        self.current_state: Optional[ExploitState] = None
        
        # AI exploitation state
        self.current_suggestions: list = []        # Current AI suggestions (PayloadEntry list)
        self.suggestion_history: List[dict] = []   # All suggestions + results for AI context
        self.ai_verdict: Optional[str] = None      # "CONFIRMED" / "FALSE_POSITIVE" / None
        self.ai_verdict_reason: str = ""
        self.exploitation_mode: bool = False        # True when actively testing a finding
        
        self.evidence_bundle = EvidenceBundle(
            session_id=str(int(datetime.now().timestamp())),
            target=target
        )
        self.payload_engine = PayloadEngine(use_ai=use_ai)
        self.repl = MCPRepl(
            handler_callback=self.handle_command,
            get_tools_fn=self.get_tool_names,
            get_findings_fn=self.get_finding_ids
        )

    def get_tool_names(self):
        return [t.name for t in self.profile.tools] if self.profile else []

    def get_finding_ids(self):
        return [str(i+1) for i in range(len(self.findings))]

    async def start(self):
        if self._owns_client:
            repl_console.print(f"[dim]Connecting to {self.target}...[/dim]")
            self.client, self.profile = await establish_connection(self.target, self.transport, self.headers)
        else:
            repl_console.print(f"[dim]Reusing existing connection to {self.target}...[/dim]")

        
        self.current_state = ExploitState(target=self.target)
        self.states.append(self.current_state)

        print_repl_banner(self.target, self.transport.value, len(self.profile.tools))
        
        if self.findings:
            repl_console.print(f"üîç Loaded {len(self.findings)} findings:")
            for i, f in enumerate(self.findings):
                sv = f.severity.value.upper()
                c = "red" if sv == "CRITICAL" else "yellow" if sv == "HIGH" else "cyan"
                text = f"  [[{i+1}]] [{c}]{sv}[/{c}] ‚Äî {f.title} (tool: {f.tool_name}, param: {f.parameter})"
                repl_console.print(text)
            repl_console.print("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n")

        await self.repl.run_loop()
        await self._shutdown()

    async def _shutdown(self):
        repl_console.print("[dim]Saving session evidence...[/dim]")
        self.evidence_bundle.exploited_states = self.states
        if self._owns_client and self.client:
            await self.client.close()
        repl_console.print("[bold green]Session closed gracefully.[/bold green]")

    async def handle_command(self, text: str):
        try:
            parts = shlex.split(text)
        except ValueError as e:
            repl_console.print(f"[red]Error parsing command:[/red] {e}")
            return
            
        if not parts:
            return
            
        cmd = parts[0].lower()
        args = parts[1:]
        
        if cmd == "help":
            print_help()
        elif cmd == "tools":
            if self.profile:
                print_tool_list(self.profile)
        elif cmd == "findings":
            for i, f in enumerate(self.findings):
                sv = f.severity.value.upper()
                repl_console.print(f"[{i+1}] [{sv}] {f.title}")
        elif cmd == "call":
            if len(args) < 2:
                repl_console.print("[red]Usage: call <tool_name> <json_args>[/red]")
                return
            tool_name = args[0]
            try:
                # Merge remaining args back into JSON string
                json_str = " ".join(args[1:])
                payload = json.loads(json_str)
            except json.JSONDecodeError:
                repl_console.print("[red]Error: Invalid JSON arguments.[/red]")
                return
            await self._execute_call(tool_name, payload)
        elif cmd == "test":
            if not args:
                repl_console.print("[red]Usage: test <finding_number>[/red]")
                return
            try:
                idx = int(args[0]) - 1
                finding = self.findings[idx]
                self.current_state = ExploitState(finding=finding, target=self.target)
                self.states.append(self.current_state)
                repl_console.print(f"[green]Testing: {finding.title}[/green]")
                
                tool_info = next((t for t in self.profile.tools if t.name == finding.tool_name), None)
                if not tool_info:
                    repl_console.print(f"[red]Tool {finding.tool_name} not found on server.[/red]")
                    return
                await self._show_suggestions(tool_info)
            except (ValueError, IndexError):
                repl_console.print("[red]Invalid finding number.[/red]")
        elif cmd == "suggest":
            if not self.current_state or not self.current_state.finding:
                repl_console.print("[yellow]No active finding test. Run 'test <no>' first.[/yellow]")
                return
            tool_info = next((t for t in self.profile.tools if t.name == self.current_state.finding.tool_name), None)
            await self._show_suggestions(tool_info)
        elif cmd == "history":
            if not self.current_state or not self.current_state.attempts:
                repl_console.print("[dim]No history in current state.[/dim]")
                return
            for i, a in enumerate(self.current_state.attempts):
                status = "[green]SUCCESS[/green]" if a.success else "[red]FAIL[/red]"
                repl_console.print(f"[{i+1}] {status} - {a.tool}: {json.dumps(a.payload)}")
        elif cmd == "poc":
            if not self.current_state:
                repl_console.print("[yellow]No active state. Run some exploits first.[/yellow]")
                return
            script = generate_poc_script(self.current_state, self.target)
            repl_console.print(Syntax(script, "python", theme="monokai"))
        elif cmd == "export":
            if not args:
                repl_console.print("[red]Usage: export <format> (formats: json, markdown)[/red]")
                return
            fmt = args[0].lower()
            self.evidence_bundle.exploited_states = self.states
            if fmt == "json":
                export_data = self.evidence_bundle.to_dict()
                filename = f"mcpsec_export_{self.evidence_bundle.session_id}.json"
                with open(filename, "w") as f:
                    json.dump(export_data, f, indent=2)
                repl_console.print(f"[green]‚úî Exported evidence to {filename}[/green]")
            elif fmt == "markdown":
                filename = f"mcpsec_export_{self.evidence_bundle.session_id}.md"
                with open(filename, "w") as f:
                    f.write(f"# mcpsec Exploitation Session\\nTarget: {self.evidence_bundle.target}\\n\\n")
                    for state in self.states:
                        title = state.finding.title if state.finding else "Manual Exploration"
                        f.write(f"## {title}\\n")
                        for a in state.attempts:
                            status = "‚úÖ" if a.success else "‚ùå"
                            f.write(f"- {status} **{a.tool}**: `{json.dumps(a.payload)}`\\n")
                repl_console.print(f"[green]‚úî Exported evidence to {filename}[/green]")
            else:
                repl_console.print("[red]Unsupported format. Use 'json' or 'markdown'.[/red]")
        elif cmd == "select":
            await self._cmd_select(args)
        elif cmd == "run":
            await self._cmd_run(args)
        elif cmd == "edit":
            await self._cmd_edit(args)
        elif cmd == "next":
            await self._cmd_next()
        elif cmd == "verdict":
            await self._cmd_verdict()
        elif cmd == "aggressive":
            await self._cmd_aggressive()
        elif cmd == "hint":
            await self._cmd_hint(args)
        elif cmd == "accept":
            await self._cmd_accept()
        elif cmd == "auto":
            await self._cmd_auto()
        elif cmd == "clear":
            print("\033c", end="")
        else:
            repl_console.print(f"[red]Unknown command:[/red] {cmd}. Type 'help' for options.")

    async def _execute_call(self, tool_name: str, payload: dict):
        repl_console.print(f"üì§ [bold]REQUEST:[/bold]")
        repl_console.print(f"  Tool: {tool_name}")
        repl_console.print(f"  Args: {json.dumps(payload)}")
        
        start = perf_counter()
        try:
            result = await self.client.call_tool(tool_name, payload)
            latency = (perf_counter() - start) * 1000
            
            response_text = ""
            is_error = getattr(result, "isError", False)
            
            # Use appropriate logic to parse Content
            if hasattr(result, "content") and result.content:
                for block in result.content:
                    if hasattr(block, "text"):
                        response_text += block.text
            elif isinstance(result, dict):
                response_text = json.dumps(result)
            else:
                response_text = str(result)
                
            repl_console.print(f"\nüì• [bold]RESPONSE[/bold] ({latency:.2f}ms):")
            color = "red" if is_error else "green"
            repl_console.print(f"[{color}]{response_text[:1000]}[/{color}]")
            if len(response_text) > 1000:
                repl_console.print(f"[dim]... (truncated)[/dim]")
                
            if self.current_state:
                self.current_state.add_attempt(tool_name, payload, response_text, latency, success=not is_error)
            # Track manual calls for AI context during exploitation mode
            if self.exploitation_mode and self.current_state:
                self.suggestion_history.append({
                    "payload": payload,
                    "description": "[MANUAL] User-provided payload",
                    "response": response_text[:500],
                    "success": not is_error,
                    "manual": True
                })
        except Exception as e:
            latency = (perf_counter() - start) * 1000
            repl_console.print(f"\nüì• [bold red]ERROR[/bold red] ({latency:.2f}ms): {e}")
            if self.current_state:
                self.current_state.add_attempt(tool_name, payload, str(e), latency, success=False)
            if self.exploitation_mode and self.current_state:
                self.suggestion_history.append({
                    "payload": payload,
                    "description": "[MANUAL] User-provided payload",
                    "response": str(e)[:500],
                    "success": False,
                    "manual": True
                })

    async def _show_suggestions(self, tool_info: Any):
        repl_console.print("[dim]Generating recommendations...[/dim]")
        payloads = await self.payload_engine.suggest_payloads(self.current_state, tool_info)
        if not payloads:
            repl_console.print("[yellow]No payloads suggested for this stage.[/yellow]")
            return
            
        repl_console.print(f"\n[bold cyan]ü§ñ Recommended Payloads (Stage: {self.current_state.stage})[/bold cyan]")
        for i, p in enumerate(payloads):
            repl_console.print(f"  [[{i+1}]] [accent]{p.payload}[/accent]")
            repl_console.print(f"      ‚Üí {p.description}")
        repl_console.print("\n[dim]Run a payload with: call <tool> <payload_json>[/dim]")

    # ‚îÄ‚îÄ‚îÄ New AI Exploitation Commands ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def _display_suggestions(self):
        """Display current AI suggestions in a numbered list."""
        if not self.current_suggestions:
            repl_console.print("[dim]No suggestions available.[/dim]")
            return

        repl_console.print(f"\n[bold cyan]ü§ñ AI Suggested Payloads:[/bold cyan]")
        for i, s in enumerate(self.current_suggestions):
            repl_console.print(f"  [{i+1}] [accent]{s.payload}[/accent]")
            repl_console.print(f"      ‚îî‚îÄ {s.description}")

        repl_console.print(f"\n[dim]Commands: 'run <N>' to execute, 'next' for more, 'verdict' for final assessment[/dim]")

    async def _cmd_select(self, args: list):
        """Select a finding and enter AI exploitation mode."""
        if not args:
            repl_console.print("[red]Usage: select <finding_number>[/red]")
            return
        try:
            idx = int(args[0]) - 1
            if idx < 0 or idx >= len(self.findings):
                repl_console.print(f"[red]Invalid finding number. Range: 1-{len(self.findings)}[/red]")
                return

            finding = self.findings[idx]
            self.current_state = ExploitState(finding=finding, target=self.target)
            self.states.append(self.current_state)
            self.exploitation_mode = True
            self.ai_verdict = None
            self.ai_verdict_reason = ""
            self.current_suggestions = []
            self.suggestion_history = []

            # Display finding details
            sv = finding.severity.value.upper()
            color = "red" if sv in ["CRITICAL", "HIGH"] else "yellow" if sv == "MEDIUM" else "cyan"
            repl_console.print(f"\n[bold]‚ïê‚ïê‚ïê Selected Finding ‚ïê‚ïê‚ïê[/bold]")
            repl_console.print(f"[{color}][{sv}][/{color}] {finding.title}")
            repl_console.print(f"  Scanner: {finding.scanner}")
            repl_console.print(f"  Tool: {finding.tool_name}")
            repl_console.print(f"  Parameter: {finding.parameter}")
            desc_preview = finding.description[:200]
            if len(finding.description) > 200:
                desc_preview += "..."
            repl_console.print(f"  Details: {desc_preview}")

            # Auto-generate initial suggestions if AI enabled
            if self.use_ai:
                repl_console.print(f"\n[dim]ü§ñ AI analyzing finding and generating initial payloads...[/dim]")
                tool_info = next((t for t in self.profile.tools if t.name == finding.tool_name), None)
                if tool_info:
                    self.current_suggestions = await self.payload_engine.generate_initial_payloads(
                        self.current_state, tool_info
                    )
                    self._display_suggestions()
                else:
                    repl_console.print(f"[yellow]Warning: Tool '{finding.tool_name}' not found on server. Use 'call' for manual testing.[/yellow]")
            else:
                repl_console.print(f"\n[yellow]AI disabled. Use 'call' to manually test, or restart with --ai[/yellow]")

        except ValueError:
            repl_console.print("[red]Invalid finding number[/red]")

    async def _cmd_run(self, args: list):
        """Execute a suggested payload by number."""
        if not self.exploitation_mode:
            repl_console.print("[yellow]No finding selected. Use 'select <N>' first.[/yellow]")
            return
        if not self.current_suggestions:
            repl_console.print("[yellow]No suggestions available. Use 'next' to generate.[/yellow]")
            return
        if not args:
            repl_console.print("[red]Usage: run <suggestion_number>[/red]")
            return

        try:
            idx = int(args[0]) - 1
            if idx < 0 or idx >= len(self.current_suggestions):
                repl_console.print(f"[red]Invalid suggestion. Range: 1-{len(self.current_suggestions)}[/red]")
                return

            suggestion = self.current_suggestions[idx]
            tool_name = self.current_state.finding.tool_name
            param_name = self.current_state.finding.parameter

            # Build the payload dict
            payload = {param_name: suggestion.payload} if param_name else {"input": suggestion.payload}

            repl_console.print(f"\n[bold cyan]‚ñ∂ Executing Payload {idx+1}[/bold cyan]")
            repl_console.print(f"  {suggestion.description}")

            await self._execute_call(tool_name, payload)

            # Record for AI context
            last_attempt = self.current_state.attempts[-1] if self.current_state.attempts else None
            self.suggestion_history.append({
                "payload": suggestion.payload,
                "description": suggestion.description,
                "response": str(last_attempt.response)[:500] if last_attempt else "",
                "success": last_attempt.success if last_attempt else False
            })

        except ValueError:
            repl_console.print("[red]Invalid suggestion number[/red]")

    async def _cmd_next(self):
        """Ask AI for next round of payloads based on learned responses."""
        if not self.exploitation_mode:
            repl_console.print("[yellow]No finding selected. Use 'select <N>' first.[/yellow]")
            return
        if not self.use_ai:
            repl_console.print("[yellow]AI disabled. Restart with --ai flag.[/yellow]")
            return

        attempt_count = len(self.current_state.attempts) if self.current_state else 0
        repl_console.print(f"\n[dim]ü§ñ AI analyzing {attempt_count} previous attempts...[/dim]")

        tool_info = next((t for t in self.profile.tools if t.name == self.current_state.finding.tool_name), None)
        if not tool_info:
            repl_console.print("[red]Tool not found on server[/red]")
            return

        self.current_suggestions = await self.payload_engine.generate_next_payloads(
            self.current_state,
            tool_info,
            self.suggestion_history
        )

        if not self.current_suggestions:
            repl_console.print("[yellow]AI has no more suggestions. Use 'verdict' for final assessment.[/yellow]")
        else:
            self._display_suggestions()

    async def _cmd_verdict(self):
        """Ask AI for final verdict: CONFIRMED or FALSE_POSITIVE."""
        if not self.exploitation_mode:
            repl_console.print("[yellow]No finding selected. Use 'select <N>' first.[/yellow]")
            return
        if not self.use_ai:
            repl_console.print("[yellow]AI disabled. Cannot render verdict.[/yellow]")
            return
        if not self.current_state.attempts:
            repl_console.print("[yellow]No attempts made yet. Run some payloads first.[/yellow]")
            return

        repl_console.print(f"\n[dim]ü§ñ AI analyzing all evidence for final verdict...[/dim]")

        verdict_result = await self.payload_engine.render_verdict(
            self.current_state,
            self.suggestion_history
        )

        self.ai_verdict = verdict_result.get("verdict", "UNKNOWN")
        self.ai_verdict_reason = verdict_result.get("reason", "")
        self.current_state.confirmed = (self.ai_verdict == "CONFIRMED")

        if self.ai_verdict == "CONFIRMED":
            repl_console.print(f"\n[bold green]‚úì VERDICT: CONFIRMED VULNERABILITY[/bold green]")
            repl_console.print(f"[green]Evidence: {self.ai_verdict_reason}[/green]")
            severity = verdict_result.get("severity_assessment", "")
            if severity:
                repl_console.print(f"[green]Severity: {severity}[/green]")
            next_steps = verdict_result.get("recommended_next_steps", "")
            if next_steps:
                repl_console.print(f"[dim]Next steps: {next_steps}[/dim]")
        elif self.ai_verdict == "FALSE_POSITIVE":
            repl_console.print(f"\n[bold yellow]‚úó VERDICT: FALSE POSITIVE[/bold yellow]")
            repl_console.print(f"[yellow]Reason: {self.ai_verdict_reason}[/yellow]")
        else:
            repl_console.print(f"\n[bold dim]? VERDICT: {self.ai_verdict}[/bold dim]")
            repl_console.print(f"[dim]Reason: {self.ai_verdict_reason}[/dim]")

        # Show continuation options ‚Äî do NOT exit exploitation_mode
        repl_console.print(f"\n[dim]Options:[/dim]")
        repl_console.print(f"  ‚Ä¢ [cyan]aggressive[/cyan] ‚Äî Force AI to try harder with bypass techniques")
        repl_console.print(f"  ‚Ä¢ [cyan]hint <text>[/cyan] ‚Äî Give AI a specific direction to try")
        repl_console.print(f"  ‚Ä¢ [cyan]next[/cyan] ‚Äî Continue with normal payload generation")
        repl_console.print(f"  ‚Ä¢ [cyan]accept[/cyan] ‚Äî Accept verdict and move on")
        if self.ai_verdict == "CONFIRMED":
            repl_console.print(f"  ‚Ä¢ [cyan]poc[/cyan] ‚Äî Generate proof-of-concept script")

    async def _cmd_auto(self):
        """Fully automatic mode: AI runs payloads until verdict."""
        if not self.exploitation_mode:
            repl_console.print("[yellow]No finding selected. Use 'select <N>' first.[/yellow]")
            return
        if not self.use_ai:
            repl_console.print("[yellow]AI disabled. Restart with --ai flag.[/yellow]")
            return

        repl_console.print(f"\n[bold cyan]ü§ñ Auto mode: AI will run payloads and render verdict.[/bold cyan]")
        repl_console.print(f"[dim]Press Ctrl+C to stop at any time.[/dim]\n")

        max_rounds = 3
        round_num = 0

        try:
            while round_num < max_rounds and self.exploitation_mode:
                round_num += 1
                repl_console.print(f"[bold]‚îÄ‚îÄ Round {round_num}/{max_rounds} ‚îÄ‚îÄ[/bold]")

                # Generate or use existing suggestions
                if not self.current_suggestions:
                    if round_num == 1:
                        tool_info = next((t for t in self.profile.tools if t.name == self.current_state.finding.tool_name), None)
                        if not tool_info:
                            repl_console.print("[red]Tool not found[/red]")
                            break
                        self.current_suggestions = await self.payload_engine.generate_initial_payloads(
                            self.current_state, tool_info
                        )
                    else:
                        tool_info = next((t for t in self.profile.tools if t.name == self.current_state.finding.tool_name), None)
                        if not tool_info:
                            break
                        self.current_suggestions = await self.payload_engine.generate_next_payloads(
                            self.current_state, tool_info, self.suggestion_history
                        )

                if not self.current_suggestions:
                    repl_console.print("[yellow]AI has no more suggestions.[/yellow]")
                    break

                self._display_suggestions()

                # Execute all suggestions in this round
                for i in range(len(self.current_suggestions)):
                    await self._cmd_run([str(i + 1)])

                # Clear suggestions for next round
                self.current_suggestions = []

            # Render verdict
            repl_console.print(f"\n[bold]‚îÄ‚îÄ Final Verdict ‚îÄ‚îÄ[/bold]")
            await self._cmd_verdict()

        except KeyboardInterrupt:
            repl_console.print("\n[yellow]Auto mode interrupted by user.[/yellow]")
            repl_console.print("[dim]Use 'verdict' to get AI assessment of attempts so far.[/dim]")

    async def _cmd_edit(self, args: list):
        """Edit an AI suggestion before running it."""
        if not self.current_suggestions:
            repl_console.print("[yellow]No suggestions to edit.[/yellow]")
            return
        if not args:
            repl_console.print("[red]Usage: edit <suggestion_number>[/red]")
            return

        try:
            idx = int(args[0]) - 1
            if idx < 0 or idx >= len(self.current_suggestions):
                repl_console.print(f"[red]Invalid suggestion. Range: 1-{len(self.current_suggestions)}[/red]")
                return

            current = self.current_suggestions[idx]
            repl_console.print(f"[dim]Current payload:[/dim] {current.payload}")

            new_payload = await self.repl.get_input("Enter modified payload (Enter to cancel): ")

            if new_payload.strip():
                self.current_suggestions[idx] = PayloadEntry(
                    payload=new_payload.strip(),
                    description=f"[EDITED] {current.description}"
                )
                repl_console.print("[green]‚úì Payload updated[/green]")
            else:
                repl_console.print("[dim]Edit cancelled[/dim]")

        except ValueError:
            repl_console.print("[red]Invalid suggestion number[/red]")

    async def _cmd_aggressive(self):
        """Force AI to try harder with bypass techniques."""
        if not self.exploitation_mode:
            repl_console.print("[yellow]No finding selected. Use 'select <N>' first.[/yellow]")
            return
        if not self.use_ai:
            repl_console.print("[yellow]AI disabled. Restart with --ai flag.[/yellow]")
            return

        repl_console.print(f"\n[bold red]üî• AI switching to AGGRESSIVE mode...[/bold red]")

        tool_info = next((t for t in self.profile.tools if t.name == self.current_state.finding.tool_name), None)
        if not tool_info:
            repl_console.print("[red]Tool not found on server[/red]")
            return

        self.current_suggestions = await self.payload_engine.generate_aggressive_payloads(
            self.current_state,
            tool_info,
            self.suggestion_history
        )

        if self.current_suggestions:
            self._display_suggestions()
        else:
            repl_console.print("[yellow]AI exhausted all aggressive techniques.[/yellow]")

    async def _cmd_hint(self, args: list):
        """Give AI a specific direction to generate payloads."""
        if not self.exploitation_mode:
            repl_console.print("[yellow]No finding selected. Use 'select <N>' first.[/yellow]")
            return
        if not self.use_ai:
            repl_console.print("[yellow]AI disabled. Restart with --ai flag.[/yellow]")
            return
        if not args:
            repl_console.print("[red]Usage: hint <your hint text>[/red]")
            repl_console.print("[dim]Example: hint try unicode normalization bypass[/dim]")
            return

        hint_text = " ".join(args)
        repl_console.print(f"\n[dim]ü§ñ AI generating payloads with hint: \"{hint_text}\"[/dim]")

        tool_info = next((t for t in self.profile.tools if t.name == self.current_state.finding.tool_name), None)
        if not tool_info:
            repl_console.print("[red]Tool not found on server[/red]")
            return

        self.current_suggestions = await self.payload_engine.generate_hinted_payloads(
            self.current_state,
            tool_info,
            self.suggestion_history,
            hint_text
        )

        if self.current_suggestions:
            self._display_suggestions()
        else:
            repl_console.print("[yellow]AI couldn't generate payloads from that hint.[/yellow]")

    async def _cmd_accept(self):
        """Accept current verdict and end exploitation for this finding."""
        if not self.exploitation_mode:
            repl_console.print("[yellow]No active exploitation session.[/yellow]")
            return

        status = "CONFIRMED" if self.current_state.confirmed else (self.ai_verdict or "UNTESTED")
        repl_console.print(f"\n[dim]Verdict accepted: {status}[/dim]")
        repl_console.print(f"[dim]Attempts recorded: {len(self.current_state.attempts)}[/dim]")

        self.exploitation_mode = False
        self.current_suggestions = []
        self.suggestion_history = []

        if len(self.findings) > 1:
            repl_console.print(f"\n[dim]Use 'findings' to see remaining findings, 'select <N>' to test another.[/dim]")
