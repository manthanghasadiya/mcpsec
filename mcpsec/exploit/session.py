"""
The main controller for the interactive session.
"""
from typing import Optional, List, Any
import json
import asyncio
from datetime import datetime
import shlex
from time import perf_counter

from rich.syntax import Syntax

from mcpsec.models import ServerProfile, Finding, TransportType
from .connection import establish_connection
from .state_tracker import ExploitState, AttemptRecord
from .evidence import EvidenceBundle, generate_poc_script
from .payload_engine import PayloadEngine
from .mcp_repl import MCPRepl
from .formatters import print_repl_banner, print_help, print_tool_list, print_json_response, repl_console

class ExploitSession:
    def __init__(self, target: str, transport: TransportType, findings: List[Finding] = None, use_ai: bool = False, headers: Optional[dict] = None, client=None, profile=None):
        self.target = target
        self.transport = transport
        self.findings = findings or []
        self.use_ai = use_ai
        self.headers = headers
        
        self.client = client
        self.profile: Optional[ServerProfile] = profile
        self._owns_client = (client is None)
        
        self.states: List[ExploitState] = []
        self.current_state: Optional[ExploitState] = None
        
        self.evidence_bundle = EvidenceBundle(
            session_id=str(int(datetime.now().timestamp())),
            target=target
        )
        self.payload_engine = PayloadEngine(use_ai=use_ai)
        self.repl = MCPRepl(
            handler_callback=self.handle_command,
            get_tools_fn=self.get_tool_names,
            get_findings_fn=self.get_finding_ids
        )

    def get_tool_names(self):
        return [t.name for t in self.profile.tools] if self.profile else []

    def get_finding_ids(self):
        return [str(i+1) for i in range(len(self.findings))]

    async def start(self):
        if self._owns_client:
            repl_console.print(f"[dim]Connecting to {self.target}...[/dim]")
            self.client, self.profile = await establish_connection(self.target, self.transport, self.headers)
        else:
            repl_console.print(f"[dim]Reusing existing connection to {self.target}...[/dim]")

        
        self.current_state = ExploitState(target=self.target)
        self.states.append(self.current_state)

        print_repl_banner(self.target, self.transport.value, len(self.profile.tools))
        
        if self.findings:
            repl_console.print(f"ğŸ” Loaded {len(self.findings)} findings:")
            for i, f in enumerate(self.findings):
                sv = f.severity.value.upper()
                c = "red" if sv == "CRITICAL" else "yellow" if sv == "HIGH" else "cyan"
                text = f"  [[{i+1}]] [{c}]{sv}[/{c}] â€” {f.title} (tool: {f.tool_name}, param: {f.parameter})"
                repl_console.print(text)
            repl_console.print("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n")

        await self.repl.run_loop()
        await self._shutdown()

    async def _shutdown(self):
        repl_console.print("[dim]Saving session evidence...[/dim]")
        self.evidence_bundle.exploited_states = self.states
        if self._owns_client and self.client:
            await self.client.close()
        repl_console.print("[bold green]Session closed gracefully.[/bold green]")

    async def handle_command(self, text: str):
        try:
            parts = shlex.split(text)
        except ValueError as e:
            repl_console.print(f"[red]Error parsing command:[/red] {e}")
            return
            
        if not parts:
            return
            
        cmd = parts[0].lower()
        args = parts[1:]
        
        if cmd == "help":
            print_help()
        elif cmd == "tools":
            if self.profile:
                print_tool_list(self.profile)
        elif cmd == "findings":
            for i, f in enumerate(self.findings):
                sv = f.severity.value.upper()
                repl_console.print(f"[{i+1}] [{sv}] {f.title}")
        elif cmd == "call":
            if len(args) < 2:
                repl_console.print("[red]Usage: call <tool_name> <json_args>[/red]")
                return
            tool_name = args[0]
            try:
                # Merge remaining args back into JSON string
                json_str = " ".join(args[1:])
                payload = json.loads(json_str)
            except json.JSONDecodeError:
                repl_console.print("[red]Error: Invalid JSON arguments.[/red]")
                return
            await self._execute_call(tool_name, payload)
        elif cmd == "test":
            if not args:
                repl_console.print("[red]Usage: test <finding_number>[/red]")
                return
            try:
                idx = int(args[0]) - 1
                finding = self.findings[idx]
                self.current_state = ExploitState(finding=finding, target=self.target)
                self.states.append(self.current_state)
                repl_console.print(f"[green]Testing: {finding.title}[/green]")
                
                tool_info = next((t for t in self.profile.tools if t.name == finding.tool_name), None)
                if not tool_info:
                    repl_console.print(f"[red]Tool {finding.tool_name} not found on server.[/red]")
                    return
                await self._show_suggestions(tool_info)
            except (ValueError, IndexError):
                repl_console.print("[red]Invalid finding number.[/red]")
        elif cmd == "suggest":
            if not self.current_state or not self.current_state.finding:
                repl_console.print("[yellow]No active finding test. Run 'test <no>' first.[/yellow]")
                return
            tool_info = next((t for t in self.profile.tools if t.name == self.current_state.finding.tool_name), None)
            await self._show_suggestions(tool_info)
        elif cmd == "history":
            if not self.current_state or not self.current_state.attempts:
                repl_console.print("[dim]No history in current state.[/dim]")
                return
            for i, a in enumerate(self.current_state.attempts):
                status = "[green]SUCCESS[/green]" if a.success else "[red]FAIL[/red]"
                repl_console.print(f"[{i+1}] {status} - {a.tool}: {json.dumps(a.payload)}")
        elif cmd == "poc":
            if not self.current_state:
                repl_console.print("[yellow]No active state. Run some exploits first.[/yellow]")
                return
            script = generate_poc_script(self.current_state, self.target)
            repl_console.print(Syntax(script, "python", theme="monokai"))
        elif cmd == "export":
            if not args:
                repl_console.print("[red]Usage: export <format> (formats: json, markdown)[/red]")
                return
            fmt = args[0].lower()
            self.evidence_bundle.exploited_states = self.states
            if fmt == "json":
                export_data = self.evidence_bundle.to_dict()
                filename = f"mcpsec_export_{self.evidence_bundle.session_id}.json"
                with open(filename, "w") as f:
                    json.dump(export_data, f, indent=2)
                repl_console.print(f"[green]âœ” Exported evidence to {filename}[/green]")
            elif fmt == "markdown":
                filename = f"mcpsec_export_{self.evidence_bundle.session_id}.md"
                with open(filename, "w") as f:
                    f.write(f"# mcpsec Exploitation Session\\nTarget: {self.evidence_bundle.target}\\n\\n")
                    for state in self.states:
                        title = state.finding.title if state.finding else "Manual Exploration"
                        f.write(f"## {title}\\n")
                        for a in state.attempts:
                            status = "âœ…" if a.success else "âŒ"
                            f.write(f"- {status} **{a.tool}**: `{json.dumps(a.payload)}`\\n")
                repl_console.print(f"[green]âœ” Exported evidence to {filename}[/green]")
            else:
                repl_console.print("[red]Unsupported format. Use 'json' or 'markdown'.[/red]")
        elif cmd == "clear":
            print("\033c", end="")
        else:
            repl_console.print(f"[red]Unknown command:[/red] {cmd}. Type 'help' for options.")

    async def _execute_call(self, tool_name: str, payload: dict):
        repl_console.print(f"ğŸ“¤ [bold]REQUEST:[/bold]")
        repl_console.print(f"  Tool: {tool_name}")
        repl_console.print(f"  Args: {json.dumps(payload)}")
        
        start = perf_counter()
        try:
            result = await self.client.call_tool(tool_name, payload)
            latency = (perf_counter() - start) * 1000
            
            response_text = ""
            is_error = getattr(result, "isError", False)
            
            # Use appropriate logic to parse Content
            if hasattr(result, "content") and result.content:
                for block in result.content:
                    if hasattr(block, "text"):
                        response_text += block.text
            elif isinstance(result, dict):
                response_text = json.dumps(result)
            else:
                response_text = str(result)
                
            repl_console.print(f"\nğŸ“¥ [bold]RESPONSE[/bold] ({latency:.2f}ms):")
            color = "red" if is_error else "green"
            repl_console.print(f"[{color}]{response_text[:1000]}[/{color}]")
            if len(response_text) > 1000:
                repl_console.print(f"[dim]... (truncated)[/dim]")
                
            if self.current_state:
                self.current_state.add_attempt(tool_name, payload, response_text, latency, success=not is_error)
        except Exception as e:
            latency = (perf_counter() - start) * 1000
            repl_console.print(f"\nğŸ“¥ [bold red]ERROR[/bold red] ({latency:.2f}ms): {e}")
            if self.current_state:
                self.current_state.add_attempt(tool_name, payload, str(e), latency, success=False)

    async def _show_suggestions(self, tool_info: Any):
        repl_console.print("[dim]Generating recommendations...[/dim]")
        payloads = await self.payload_engine.suggest_payloads(self.current_state, tool_info)
        if not payloads:
            repl_console.print("[yellow]No payloads suggested for this stage.[/yellow]")
            return
            
        repl_console.print(f"\n[bold cyan]ğŸ¤– Recommended Payloads (Stage: {self.current_state.stage})[/bold cyan]")
        for i, p in enumerate(payloads):
            repl_console.print(f"  [[{i+1}]] [accent]{p.payload}[/accent]")
            repl_console.print(f"      â†’ {p.description}")
        repl_console.print("\n[dim]Run a payload with: call <tool> <payload_json>[/dim]")
