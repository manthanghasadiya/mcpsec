"""
Payload recommendation engine that combines static playbooks and AI logic.
"""
from typing import List, Optional, Any
import json
from mcpsec.models import ToolInfo
from .state_tracker import ExploitState
from .playbooks import PLAYBOOKS, Playbook, ExploitStage, PayloadEntry

class PayloadEngine:
    def __init__(self, use_ai: bool = False):
        self.use_ai = use_ai
        self.ai_client = None
        if self.use_ai:
            from mcpsec.ai.client import get_ai_client
            try:
                self.ai_client = get_ai_client()
            except Exception:
                self.use_ai = False

    def get_playbook(self, state: ExploitState) -> Playbook:
        """Retrieves the appropriate playbook based on the finding's scanner."""
        if not state.finding:
            return PLAYBOOKS["generic"]
            
        vuln_type = state.finding.scanner.replace("ai-", "").lower()
        if vuln_type not in PLAYBOOKS:
            # Map common names
            if "sql" in vuln_type.lower():
                vuln_type = "sqli"
            elif "rce" in vuln_type.lower() or "command" in vuln_type.lower():
                vuln_type = "command_injection"
            elif "path" in vuln_type.lower() or "traversal" in vuln_type.lower():
                vuln_type = "path_traversal"
            else:
                vuln_type = "generic"
                
        return PLAYBOOKS.get(vuln_type, PLAYBOOKS["generic"])

    async def suggest_payloads(self, state: ExploitState, tool: ToolInfo) -> List[PayloadEntry]:
        """Suggests next payloads based on current state and playbook."""
        playbook = self.get_playbook(state)
        
        # Find the current stage
        current_stage = next((s for s in playbook.stages if s.name == state.stage), playbook.stages[0])
        
        static_payloads = current_stage.payloads
        
        if self.use_ai and self.ai_client:
            ai_payloads = await self._get_ai_recommendations(state, tool, current_stage)
            # Prepend AI payloads so they show up vividly or just return them all
            return static_payloads + ai_payloads
            
        return static_payloads

    async def _get_ai_recommendations(self, state: ExploitState, tool: ToolInfo, current_stage: ExploitStage) -> List[PayloadEntry]:
        """Queries the AI client for intelligent payload recommendations."""
        
        finding_info = "Manual Exploration"
        if state.finding:
            finding_info = (f"Type: {state.finding.scanner}\\n"
                            f"Tool: {state.finding.tool_name}\\n"
                            f"Parameter: {state.finding.parameter}\\n"
                            f"Original Details: {state.finding.description}")

        attempts_log = ""
        for i, a in enumerate(state.attempts):
            success = "SUCCESS" if a.success else "FAILED"
            attempts_log += f"Attempt {i+1}:\\nPayload: {json.dumps(a.payload)}\\nResult: ({success}) {str(a.response)[:200]}\\n\\n"

        prompt = f"""You are an MCP security exploitation copilot helping validate and exploit a finding.

SERVER CONTEXT:
- Target: {state.target}
- Available Tool: {tool.name}
- Parameters: {json.dumps(tool.raw_schema)}

FINDING:
{finding_info}

EXPLOITATION STATE:
- Stage: {current_stage.name} - {current_stage.description}
- AI Escalation Prompt: {current_stage.ai_escalation_prompt}
- Attempts so far:
{attempts_log if attempts_log else 'No prior attempts.'}

- Server Behavior Learned: {json.dumps(state.server_behavior)}

TASK:
Recommend exactly 3 intelligent payloads for the next step.
Return your answer strictly as a JSON array of objects, with each object containing:
- "payload": The specific value to inject (use as raw primitive or object as expected by parameter).
- "description": A short, scannable one-line explanation of what it tests and aims to achieve.
Example Output:
[ {{"payload": "../../etc/passwd", "description": "Tests basic traversal."}}, ... ]
"""

        try:
            response = await self.ai_client.generate(
                prompt=prompt,
                system="You are a penetration testing tool. Output ONLY pure JSON array without markdown formatting.",
                temperature=0.4
            )
            
            # Clean possible markdown block
            text = response.text.strip()
            if text.startswith("```json"):
                text = text[7:-3].strip()
            elif text.startswith("```"):
                text = text[3:-3].strip()
                
            data = json.loads(text)
            
            results = []
            for item in data:
                # the payload from AI is mapping to the vulnerable parameter. 
                # Our PayloadEntry expects just the value, not the fully formed argument dict yet.
                results.append(PayloadEntry(
                    payload=item.get("payload", ""),
                    description=f"[AI] {item.get('description', 'AI Suggested')}"
                ))
            return results
        except Exception as e:
            # On generic errors, fallback strictly to static
            return []
