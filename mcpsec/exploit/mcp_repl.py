"""
REPL interface for the exploitation session using prompt_toolkit.
"""
from typing import Callable, Coroutine, Any, List
from prompt_toolkit import PromptSession
from prompt_toolkit.completion import WordCompleter, Completer, Completion
from prompt_toolkit.styles import Style
import shlex

COMMANDS = [
    "help", "tools", "findings", "history", "status",
    "call", "raw", "test", "explore", "payloads", 
    "suggest", "inject", "custom", "evidence", "export", 
    "select", "run", "edit", "next", "verdict",
    "aggressive", "hint", "accept", "auto",
    "poc", "clear", "save", "quit", "exit"
]

class CommandCompleter(Completer):
    def __init__(self, get_tools_fn, get_findings_fn):
        self.get_tools_fn = get_tools_fn
        self.get_findings_fn = get_findings_fn
        self.base_completer = WordCompleter(COMMANDS, ignore_case=True)

    def get_completions(self, document, complete_event):
        text_before_cursor = document.text_before_cursor
        
        try:
            # We use shlex to parse carefully handling quotes
            words = shlex.split(text_before_cursor)
        except ValueError:
            words = text_before_cursor.split(' ')

        if len(words) == 0:
            yield from self.base_completer.get_completions(document, complete_event)
        elif len(words) == 1 and not text_before_cursor.endswith(' '):
            # completing the first command word
            yield from self.base_completer.get_completions(document, complete_event)
        elif len(words) >= 1:
            cmd = words[0].lower()
            if cmd in ("call", "custom") and (len(words) == 2 and not text_before_cursor.endswith(' ') or len(words) == 1):
                # Autocomplete tool names
                tools = self.get_tools_fn()
                word_before_cursor = words[1] if len(words) == 2 else ""
                for t in tools:
                    if t.startswith(word_before_cursor):
                        yield Completion(t, start_position=-len(word_before_cursor))

class MCPRepl:
    def __init__(self, handler_callback, get_tools_fn, get_findings_fn):
        self.handler_callback = handler_callback
        self.completer = CommandCompleter(get_tools_fn, get_findings_fn)
        self.style = Style.from_dict({
            'prompt': 'ansicyan bold',
        })
        self.prompt_session = PromptSession(
            completer=self.completer,
            style=self.style
        )

    async def run_loop(self):
        """Runs the async prompt loop."""
        while True:
            try:
                text = await self.prompt_session.prompt_async("mcpsec> ")
                text = text.strip()
                if not text:
                    continue
                if text.lower() in ("exit", "quit"):
                    break
                await self.handler_callback(text)
            except KeyboardInterrupt:
                continue
            except EOFError:
                break
            except Exception as e:
                print(f"REPL Error: {e}")

    async def get_input(self, prompt_text: str) -> str:
        """Prompt user for inline input (e.g. for edit command)."""
        try:
            return await self.prompt_session.prompt_async(prompt_text)
        except (KeyboardInterrupt, EOFError):
            return ""
